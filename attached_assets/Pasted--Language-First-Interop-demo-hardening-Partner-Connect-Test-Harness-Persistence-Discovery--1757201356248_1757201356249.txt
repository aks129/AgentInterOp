# === Language-First Interop demo hardening: Partner Connect, Test Harness, Persistence, Discovery ===
# This patch adds:
# - Partner Connect page (drive A2A/MCP against a partner endpoint; raw frames view)
# - Test Harness page (scripted happy/error paths for A2A + MCP)
# - Discovery endpoints: /healthz, /.well-known/agent-card.json, /api/selftest, /api/loopback/sse
# - Trace download endpoint
# - Persistence switch: STORE=memory|sqlite (SQLite file: data/agent.db)
# - Canned FHIR patient bundle fallback
# - UI links to API Docs (/docs) and the new tools

# -----------------------------
# 0) Folders
# -----------------------------
create folder data
create folder app/demo

# -----------------------------
# 1) Persistence (memory | sqlite)
# -----------------------------
create file app/store/persistence.py with:
import os, json, sqlite3, threading
from typing import Any, Dict, List, Optional, Tuple

STORE = os.getenv("STORE", "memory").lower()
DB_PATH = os.getenv("DB_PATH", "data/agent.db")

_lock = threading.RLock()
_mem = {
    "contexts": {},   # contextId -> {scenario, config, created_at}
    "tasks": {},      # taskId -> {contextId, status, history}
    "messages": [],   # [{contextId, role, at, parts, meta}]
    "traces": {}      # contextId -> [ {ts, actor, action, detail} ]
}

def _ensure_db():
    os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""create table if not exists contexts(
        id text primary key, data text, created_at text)""")
    c.execute("""create table if not exists tasks(
        id text primary key, context_id text, data text)""")
    c.execute("""create table if not exists messages(
        id integer primary key autoincrement, context_id text, role text, at text, parts text, meta text)""")
    c.execute("""create table if not exists traces(
        id integer primary key autoincrement, context_id text, ts text, actor text, action text, detail text)""")
    conn.commit(); conn.close()

if STORE == "sqlite":
    _ensure_db()

def save_context(context_id: str, data: Dict[str, Any], created_at: str):
    with _lock:
        if STORE == "sqlite":
            conn=sqlite3.connect(DB_PATH); c=conn.cursor()
            c.execute("insert or replace into contexts(id,data,created_at) values(?,?,?)",(context_id,json.dumps(data),created_at))
            conn.commit(); conn.close()
        else:
            _mem["contexts"][context_id] = {**data, "created_at": created_at}

def get_context(context_id: str) -> Optional[Dict[str, Any]]:
    with _lock:
        if STORE == "sqlite":
            conn=sqlite3.connect(DB_PATH); c=conn.cursor()
            c.execute("select data from contexts where id=?",(context_id,))
            row=c.fetchone(); conn.close()
            return json.loads(row[0]) if row else None
        else:
            return _mem["contexts"].get(context_id)

def append_message(context_id: str, role: str, at: str, parts: Any, meta: Dict[str,Any]|None=None):
    rec={"contextId":context_id,"role":role,"at":at,"parts":parts,"meta":meta or {}}
    with _lock:
        if STORE == "sqlite":
            conn=sqlite3.connect(DB_PATH); c=conn.cursor()
            c.execute("insert into messages(context_id,role,at,parts,meta) values(?,?,?,?,?)",
                      (context_id,role,at,json.dumps(parts),json.dumps(meta or {})))
            conn.commit(); conn.close()
        else:
            _mem["messages"].append(rec)

def list_messages(context_id: str) -> List[Dict[str,Any]]:
    with _lock:
        if STORE == "sqlite":
            conn=sqlite3.connect(DB_PATH); c=conn.cursor()
            c.execute("select role,at,parts,meta from messages where context_id=? order by id",(context_id,))
            rows=c.fetchall(); conn.close()
            return [{"role":r,"at":a,"parts":json.loads(p),"meta":json.loads(m)} for (r,a,p,m) in rows]
        else:
            return [m for m in _mem["messages"] if m["contextId"]==context_id]

def trace(context_id: str, ts: str, actor: str, action: str, detail: Dict[str,Any]):
    with _lock:
        if STORE == "sqlite":
            conn=sqlite3.connect(DB_PATH); c=conn.cursor()
            c.execute("insert into traces(context_id,ts,actor,action,detail) values(?,?,?,?,?)",
                      (context_id,ts,actor,action,json.dumps(detail)))
            conn.commit(); conn.close()
        else:
            _mem["traces"].setdefault(context_id,[]).append({"ts":ts,"actor":actor,"action":action,"detail":detail})

def list_traces(context_id: str) -> List[Dict[str,Any]]:
    with _lock:
        if STORE == "sqlite":
            conn=sqlite3.connect(DB_PATH); c=conn.cursor()
            c.execute("select ts,actor,action,detail from traces where context_id=? order by id",(context_id,))
            rows=c.fetchall(); conn.close()
            return [{"ts":t,"actor":a,"action":ac,"detail":json.loads(d)} for (t,a,ac,d) in rows]
        else:
            return _mem["traces"].get(context_id,[])

# -----------------------------
# 2) Canned FHIR bundle
# -----------------------------
create file app/demo/patient_001.json with:
{
  "resourceType":"Bundle",
  "type":"collection",
  "entry":[
    {"resource":{"resourceType":"Patient","id":"demo-001","gender":"female","birthDate":"1969-04-21"}},
    {"resource":{"resourceType":"Procedure","id":"mammo-1","code":{"coding":[{"system":"http://www.ama-assn.org/go/cpt","code":"77067","display":"Screening mammography"}},"performedDateTime":"2024-10-15"}}
  ]
}

# -----------------------------
# 3) Discovery + utilities
# -----------------------------
open app/main.py and insert (edit; avoid duplicates):
- A /healthz route returning {"ok": true}
- A /.well-known/agent-card.json route returning JSON with protocolVersion "0.2.9", preferredTransport "JSONRPC", capabilities.streaming true, and an a2a endpoint path like "/api/bridge/demo/a2a"
- A /api/selftest route returning: supported A2A methods, MCP tools, scenarios list, STORE backend, and a short SSE token
- A /api/loopback/sse route that emits 3 SSE frames (event: message) then a final status-update {final:true}
- A /api/trace/{contextId}/download route that returns application/json of list_traces(contextId)

# (Implementation hint)
# from fastapi import APIRouter, Request
# from fastapi.responses import JSONResponse, StreamingResponse
# import time, json
# from app.store.persistence import list_traces
# @app.get("/.well-known/agent-card.json")
# def agent_card(request: Request):
#    base = str(request.base_url).rstrip("/")
#    return {"protocolVersion":"0.2.9","preferredTransport":"JSONRPC","capabilities":{"streaming":True},
#            "skills":[{"id":"scenario","a2a":{"config64":"ZGVtby1jb25maWc="}}],"endpoints":{"jsonrpc": f"{base}/api/bridge/demo/a2a"}}
# @app.get("/api/selftest")
# def selftest(): return {"ok":True,"a2a":["message/send","message/stream","tasks/get","tasks/cancel"],"mcp":["begin_chat_thread","send_message_to_chat_thread","check_replies"],"store":os.getenv("STORE","memory")}
# @app.get("/api/loopback/sse")
# def loop_sse():
#   def gen():
#     yield "event: message\ndata: {\"kind\":\"task\",\"status\":{\"state\":\"working\"}}\n\n"
#     time.sleep(0.3); yield "event: message\ndata: {\"role\":\"agent\",\"parts\":[{\"kind\":\"text\",\"text\":\"hello\"}],\"kind\":\"message\"}\n\n"
#     time.sleep(0.3); yield "event: status-update\ndata: {\"final\":true,\"status\":{\"state\":\"completed\"}}\n\n"
#   return StreamingResponse(gen(), media_type="text/event-stream")
# @app.get("/api/trace/{contextId}/download")
# def dl(contextId:str): return JSONResponse(list_traces(contextId))

# -----------------------------
# 4) Partner Connect UI
# -----------------------------
create file app/web/templates/partner_connect.html with:
<!doctype html><html><head><meta charset="utf-8"><title>Partner Connect</title>
<link rel="stylesheet" href="/static/style.css"></head><body>
<h1>Partner Connect</h1>
<p>Drive A2A/MCP against a partner endpoint and see raw frames.</p>
<section>
  <label>Partner A2A JSON-RPC Endpoint</label>
  <input id="a2a" placeholder="https://partner.example.com/api/bridge/room/a2a" style="width: 100%;">
  <div style="margin-top:8px;">
    <button onclick="ping()">Ping (message/send)</button>
    <button onclick="stream()">Stream (message/stream)</button>
    <button onclick="cancel()">Cancel</button>
  </div>
</section>
<section style="margin-top:16px;">
  <h3>Frames</h3>
  <pre id="log" style="background:#111;color:#0f0;padding:12px;white-space:pre-wrap;min-height:200px;"></pre>
</section>
<script>
let lastTaskId = null;
function log(x){ const el=document.getElementById('log'); el.textContent += x + "\\n"; el.scrollTop=el.scrollHeight; }
async function ping(){
  const url=document.getElementById('a2a').value.trim(); if(!url) return;
  const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},
    body: JSON.stringify({"jsonrpc":"2.0","id":"1","method":"message/send","params":{"message":{"parts":[{"kind":"text","text":"Hello, please begin."}]}}})
  });
  const j=await res.json(); lastTaskId = j?.result?.id || null; log("SEND => " + JSON.stringify(j));
}
async function stream(){
  const url=document.getElementById('a2a').value.trim(); if(!url) return;
  const es = new EventSource(url, { withCredentials:false }); // expecting server to honor Accept: text/event-stream when POST; fallback demo
  log("NOTE: If server requires POST-SSE, use curl on console; this viewer is illustrative.");
}
async function cancel(){
  const url=document.getElementById('a2a').value.trim(); if(!url||!lastTaskId) return;
  const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},
    body: JSON.stringify({"jsonrpc":"2.0","id":"cx","method":"tasks/cancel","params":{"id":String(lastTaskId)}})
  });
  const j=await res.json(); log("CANCEL => " + JSON.stringify(j));
}
</script>
<p style="margin-top:24px;"><a href="/">🏠 Home</a> · <a href="/test_harness">Test Harness</a> · <a href="/docs">OpenAPI Docs</a></p>
</body></html>

# -----------------------------
# 5) Test Harness UI (scripted tests)
# -----------------------------
create file app/web/templates/test_harness.html with:
<!doctype html><html><head><meta charset="utf-8"><title>Test Harness</title>
<link rel="stylesheet" href="/static/style.css"></head><body>
<h1>Test Harness</h1>
<p>Run scripted scenarios to verify envelopes, states, SSE, MCP.</p>
<div>
  <button onclick="a2aHappy()">A2A Happy Path</button>
  <button onclick="a2aError()">A2A Error Path</button>
  <button onclick="mcpTriplet()">MCP Triplet</button>
  <button onclick="sseLoop()">SSE Loopback</button>
</div>
<pre id="out" style="background:#111;color:#0f0;padding:12px;white-space:pre-wrap;min-height:240px;margin-top:12px;"></pre>
<script>
function p(s){ const el=document.getElementById('out'); el.textContent += s + "\\n"; el.scrollTop=el.scrollHeight; }
async function a2aHappy(){
  p("A2A: message/send"); 
  const res=await fetch("/api/bridge/demo/a2a",{method:"POST",headers:{'Content-Type':'application/json'},
   body: JSON.stringify({"jsonrpc":"2.0","id":"1","method":"message/send","params":{"message":{"parts":[{"kind":"text","text":"Begin."}]}}})});
  const j=await res.json(); p(JSON.stringify(j)); const tid=j?.result?.id;
  p("A2A: tasks/get"); const g=await fetch("/api/bridge/demo/a2a",{method:"POST",headers:{'Content-Type':'application/json'},
   body: JSON.stringify({"jsonrpc":"2.0","id":"g1","method":"tasks/get","params":{"id":tid}})}); p(JSON.stringify(await g.json()));
}
async function a2aError(){
  p("A2A: bad method"); const r=await fetch("/api/bridge/demo/a2a",{method:"POST",headers:{'Content-Type':'application/json'},
   body: JSON.stringify({"jsonrpc":"2.0","id":"x","method":"does/not/exist","params":{}})}); p(JSON.stringify(await r.json()));
}
async function mcpTriplet(){
  p("MCP: begin_chat_thread"); let r=await fetch("/api/mcp/begin_chat_thread",{method:"POST"}); p(await r.text());
  p("MCP: send_message_to_chat_thread"); r=await fetch("/api/mcp/send_message_to_chat_thread",{method:"POST",headers:{'Content-Type':'application/json'},
   body: JSON.stringify({"conversationId":"42","message":"Hello from harness"})}); p(await r.text());
  p("MCP: check_replies"); r=await fetch("/api/mcp/check_replies",{method:"POST",headers:{'Content-Type':'application/json'},
   body: JSON.stringify({"conversationId":"42","waitMs":500})}); p(await r.text());
}
async function sseLoop(){
  p("SSE loopback:");
  const ev=new EventSource("/api/loopback/sse");
  ev.onmessage=(e)=>p("EVENT message => " + e.data);
}
</script>
<p><a href="/">🏠 Home</a> · <a href="/partner_connect">Partner Connect</a> · <a href="/docs">OpenAPI Docs</a></p>
</body></html>

# -----------------------------
# 6) Wire routes for the new pages
# -----------------------------
open app/main.py and add (near other routes):
# from fastapi import Request
# @app.get("/partner_connect")
# def partner_page(request: Request):
#   if not templates: return {"ok": True, "message": "Templates not bundled; use /docs"}
#   return templates.TemplateResponse("partner_connect.html", {"request": request})
# @app.get("/test_harness")
# def harness_page(request: Request):
#   if not templates: return {"ok": True, "message": "Templates not bundled; use /docs"}
#   return templates.TemplateResponse("test_harness.html", {"request": request})

# Also add links on your index route body to /partner_connect, /test_harness, /docs.

# -----------------------------
# 7) Ingestion fallback: canned bundle
# -----------------------------
open app/main.py and add a route:
# @app.post("/api/ingest/demo")
# def ingest_demo():
#   from pathlib import Path, PurePosixPath
#   import json
#   p = Path(__file__).resolve().parent / "demo" / "patient_001.json"
#   data = json.loads(p.read_text())
#   # Call your existing ingestion mapper here if available, else return bundle
#   return {"ok": True, "bundle": data}

# -----------------------------
# 8) Requirements (ensure deps)
# -----------------------------
open requirements.txt and ensure it contains at least:
# fastapi
# pydantic
# jinja2
# httpx
# python-multipart
# sse-starlette
# sqlite3 is stdlib; no package required

# -----------------------------
# 9) README quick-start (optional)
# -----------------------------
append file README.md with:
## Demo Utilities
- **Partner Connect**: `/partner_connect` — drive a partner A2A endpoint and view frames.
- **Test Harness**: `/test_harness` — scripted checks for A2A/MCP/SSE.
- **Discovery**: `/healthz`, `/api/selftest`, `/.well-known/agent-card.json`, `/api/loopback/sse`.
- **Trace Download**: `/api/trace/{contextId}/download`.
- **Persistence**: set `STORE=sqlite` for durable runs (DB at `data/agent.db`); default `STORE=memory`.
- **FHIR Fallback**: `POST /api/ingest/demo` loads a canned bundle for offline demos.

# === END PATCH ===
