# === FINAL PARTNER-TEST PATCH: BCS-only, A2A/MCP endpoints, discovery, canned FHIR, SSE, error codes ===

# 0) Ensure package + minimal deps (if missing)
create file app/__init__.py with:
# intentionally empty

open requirements.txt and ensure it contains at least:
fastapi
pydantic
jinja2
httpx
python-multipart
sse-starlette

# 1) Discovery + testing utilities (health, agent-card, selftest, version)
open app/main.py and INSERT/ADJUST (edit; avoid duplicates):
# --- imports ---
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse, PlainTextResponse, StreamingResponse
from datetime import datetime, timezone
from pathlib import Path
import os, json, time, base64

app = FastAPI(title="AgentInterOp", version="1.0.0-bcse")

@app.get("/healthz")
def healthz():
    return {"ok": True, "ts": datetime.now(timezone.utc).isoformat()}

@app.get("/version")
def version():
    return {"name": "AgentInterOp", "version": app.version, "scenario": "bcse"}

@app.get("/.well-known/agent-card.json")
def agent_card(request: Request):
    base = str(request.base_url).rstrip("/")
    card = {
      "protocolVersion": "0.2.9",
      "preferredTransport": "JSONRPC",
      "capabilities": {"streaming": True},
      "skills": [
        { "id": "bcse", "a2a": { "config64": base64.b64encode(b'{"scenario":"bcse"}').decode() } }
      ],
      "endpoints": { "jsonrpc": f"{base}/api/bridge/bcse/a2a" }
    }
    return JSONResponse(card)

@app.get("/api/selftest")
def selftest():
    return {"ok": True,
            "a2a": ["message/send","message/stream","tasks/get","tasks/cancel"],
            "mcp": ["begin_chat_thread","send_message_to_chat_thread","check_replies"],
            "scenario": "bcse"}

# 2) Minimal BCS evaluator and FHIR mapping (canned & live-ready)
create file app/scenarios/bcse.py with:
from datetime import datetime, timedelta, date
from typing import Dict, Any

def _parse_date(d: str|None) -> date|None:
    if not d: return None
    try: return date.fromisoformat(d[:10])
    except: return None

def evaluate(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Minimal BCS: eligible if female AND 50-74 AND last_mammogram within 27 months.
    """
    sex = (payload.get("sex") or "").lower()
    birth = _parse_date(payload.get("birthDate"))
    last = _parse_date(payload.get("last_mammogram"))

    reasons = []
    now = date.today()
    age = None
    if birth:
        age = now.year - birth.year - ((now.month, now.day) < (birth.month, birth.day))

    # Checks
    if sex != "female": reasons.append("Requires female sex.")
    if age is None: reasons.append("Missing birthDate.")
    elif age < 50 or age > 74: reasons.append(f"Age {age} outside 50-74 window.")
    if not last: reasons.append("Missing last_mammogram date.")

    if reasons:
        # If only missing mammogram, ask for info; else ineligible
        if len(reasons)==1 and "Missing last_mammogram" in reasons[0]:
            return {"status":"needs-more-info","rationale":reasons,"request":"Provide prior mammogram date (CPT 77067) within last 27 months."}
        return {"status":"ineligible","rationale":reasons}

    months27 = (now - last).days <= int(27*30.44)
    if months27:
        return {"status":"eligible","rationale":[f"Age {age}, female, mammogram within 27 months."]}
    else:
        return {"status":"needs-more-info","rationale":[f"Last mammogram older than 27 months."],"request":"Schedule screening mammogram."}

def map_fhir_bundle(bundle: Dict[str,Any]) -> Dict[str,Any]:
    """Very small mapper: Patient.birthDate, Patient.gender, Procedure CPT 77067 performedDateTime."""
    sex, birth, last = None, None, None
    for e in (bundle.get("entry") or []):
        r = e.get("resource") or {}
        rt = r.get("resourceType")
        if rt == "Patient":
            birth = r.get("birthDate") or birth
            sex = r.get("gender") or sex
        elif rt == "Procedure":
            code = (r.get("code") or {}).get("coding") or []
            for c in code:
                if c.get("system") == "http://www.ama-assn.org/go/cpt" and c.get("code") == "77067":
                    last = r.get("performedDateTime") or last
    return {"sex": sex, "birthDate": birth, "last_mammogram": last}

create file app/demo/patient_bcse.json with:
{
  "resourceType":"Bundle","type":"collection",
  "entry":[
    {"resource":{"resourceType":"Patient","id":"demo-001","gender":"female","birthDate":"1968-05-10"}},
    {"resource":{"resourceType":"Procedure","id":"mammo-1","code":{"coding":[{"system":"http://www.ama-assn.org/go/cpt","code":"77067","display":"Screening mammography"}]},"performedDateTime":"2024-12-01"}}
  ]
}

# 3) BCS REST endpoints (ingest + evaluate) to mirror admin/applicant flow
open app/main.py and INSERT:
from app.scenarios import bcse as BCS

@app.post("/api/bcse/ingest/demo")
def bcse_ingest_demo():
    p = Path(__file__).resolve().parent / "demo" / "patient_bcse.json"
    bundle = json.loads(p.read_text())
    return {"ok": True, "applicant_payload": BCS.map_fhir_bundle(bundle), "source": "demo"}

@app.post("/api/bcse/evaluate")
def bcse_evaluate(payload: dict):
    """
    Body: { "sex": "...", "birthDate": "YYYY-MM-DD", "last_mammogram": "YYYY-MM-DD" }
    """
    decision = BCS.evaluate(payload or {})
    return {"ok": True, "decision": decision}

# 4) A2A JSON-RPC (BCS-only surface) with correct error codes and SSE
create file app/protocols/a2a_bcse.py with:
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse, StreamingResponse
from datetime import datetime, timezone
import json, time, uuid
from app.scenarios import bcse as BCS

router = APIRouter(prefix="/api/bridge/bcse/a2a", tags=["A2A-BCSE"])

_TASKS = {}  # taskId -> snapshot (in-memory for demo)

def _task_snapshot(tid, state, history=None, artifacts=None, context=None):
    return {
      "id": tid, "contextId": tid,
      "status": {"state": state},
      "history": history or [],
      "artifacts": artifacts or [],
      "kind":"task",
      "metadata": context or {}
    }

def _ok(result): return JSONResponse({"jsonrpc":"2.0","id":"1","result":result})
def _err(id_, code, message, data=None):
    return JSONResponse({"jsonrpc":"2.0","id":id_,"error":{"code":code,"message":message,"data":data or {}}}, status_code=200)

@router.post("")
async def rpc(req: Request):
    body = await req.json()
    method = body.get("method")
    id_ = body.get("id","1")
    params = body.get("params") or {}
    if method == "message/send":
        parts = (params.get("message") or {}).get("parts") or []
        text = next((p.get("text") for p in parts if p.get("kind")=="text"),"")
        tid = str(uuid.uuid4())[:8]
        history = [{"role":"user","parts":parts,"kind":"message"}]
        # If text contains a JSON payload, evaluate BCS
        decision=None
        try:
            for p in parts:
                if p.get("kind")=="text" and "{" in p.get("text",""):
                    decision = BCS.evaluate(json.loads(p["text"]))
        except Exception as e:
            pass
        snap = _task_snapshot(tid, "working", history=history, context={"scenario":"bcse"})
        if decision:
            snap["history"].append({"role":"agent","parts":[{"kind":"text","text":json.dumps(decision)}],"kind":"message"})
            snap["status"] = {"state":"completed"}
        _TASKS[tid]=snap
        return _ok(snap)
    elif method == "message/stream":
        # SSE stream: submitted -> working -> (agent message) -> input-required
        def gen():
            tid = str(uuid.uuid4())[:8]
            snap = _task_snapshot(tid, "working", history=[{"role":"user","parts":[],"kind":"message"}], context={"scenario":"bcse"})
            _TASKS[tid]=snap
            yield f"data: {json.dumps({'jsonrpc':'2.0','id':'sse','result':{'id':tid,'status':{'state':'working'},'kind':'task'}})}\n\n"
            time.sleep(0.2)
            msg = {"role":"agent","parts":[{"kind":"text","text":"Provide sex, birthDate, last_mammogram (YYYY-MM-DD)."}],"kind":"message"}
            yield f"data: {json.dumps({'jsonrpc':'2.0','id':'sse','result':msg})}\n\n"
            time.sleep(0.2)
            yield f"data: {json.dumps({'jsonrpc':'2.0','id':'sse','result':{'kind':'status-update','status':{'state':'input-required'},'final':True}})}\n\n"
        return StreamingResponse(gen(), media_type="text/event-stream")
    elif method == "tasks/get":
        tid = (params or {}).get("id")
        if not tid or tid not in _TASKS:
            return _err(id_, -32001, "Task not found")
        return _ok(_TASKS[tid])
    elif method == "tasks/cancel":
        tid = (params or {}).get("id")
        if not tid or tid not in _TASKS:
            return _err(id_, -32001, "Task not found")
        snap=_TASKS[tid]; snap["status"]={"state":"canceled"}; return _ok(snap)
    else:
        return _err(id_, -32601, "Method not found")

# 5) MCP (BCS-only, simplified)
create file app/protocols/mcp_bcse.py with:
from fastapi import APIRouter, Request
from fastapi.responses import JSONResponse
from datetime import datetime, timezone
import json
from app.scenarios import bcse as BCS

router = APIRouter(prefix="/api/mcp/bcse", tags=["MCP-BCSE"])

_CONV = {}

@router.post("/begin_chat_thread")
async def begin():
    cid = datetime.now(timezone.utc).strftime("bcse-%H%M%S")
    _CONV[cid] = []
    return JSONResponse({"content":[{"type":"text","text":json.dumps({"conversationId":cid})}]})

@router.post("/send_message_to_chat_thread")
async def send(req: Request):
    body = await req.json()
    cid = body.get("conversationId")
    msg = body.get("message") or ""
    _CONV.setdefault(cid,[]).append({"from":"applicant","text":msg})
    return JSONResponse({"guidance":"Message received","status":"working"})

@router.post("/check_replies")
async def check(req: Request):
    body = await req.json()
    cid = body.get("conversationId")
    turn = {"from":"administrator","at": datetime.now(timezone.utc).isoformat(),
            "text":"Provide sex, birthDate, last_mammogram (YYYY-MM-DD).","attachments":[]}
    return JSONResponse({
      "messages":[turn],
      "guidance":"Agent administrator finished a turn. It's your turn to respond.",
      "status":"input-required","conversation_ended": False
    })

# 6) Plug in routers
open app/main.py and ADD after app = FastAPI(...):
from app.protocols.a2a_bcse import router as a2a_bcse_router
from app.protocols.mcp_bcse import router as mcp_bcse_router
app.include_router(a2a_bcse_router)
app.include_router(mcp_bcse_router)

# 7) README: shareable partner endpoints + ready-to-run curls
append file README.md with:
## Share with Partners (BCS only)
Base URL: `<YOUR_BASE_URL>`

Discovery:
- Health: `GET /healthz`
- Version: `GET /version`
- Agent Card: `GET /.well-known/agent-card.json`
- Self-Test: `GET /api/selftest`
- OpenAPI: `/docs`

### A2A (BCS) â€” JSON-RPC over HTTP
**message/send (text prompt):**
```bash
curl -s <BASE>/api/bridge/bcse/a2a -H 'Content-Type: application/json' -d '{
  "jsonrpc":"2.0","id":"1","method":"message/send",
  "params":{"message":{"parts":[{"kind":"text","text":"Hello, begin."}]}}
}'
