# === VERCEL HARDENING + SAFE-MODE PATCH ===
# This will:
# - add a safe wrapper so import errors show in the browser
# - route all traffic to your FastAPI app
# - use /tmp for writes on Vercel
# - make app import-safe (no heavy work at import time)

# 1) vercel.json (legacy-compatible "builds" config that works across projects)
create file vercel.json with:
{
  "version": 2,
  "builds": [
    { "src": "api/index.py", "use": "@vercel/python" }
  ],
  "routes": [
    { "src": "/(.*)", "dest": "api/index.py" }
  ],
  "framework": null
}

# 2) api/index.py — safe-mode ASGI entrypoint (shows tracebacks on import failure)
create file api/index.py with:
import os, sys, traceback
os.environ.setdefault("APP_ENV", "vercel")  # used to switch to /tmp, etc.

try:
    # IMPORTANT: app must be importable without side effects
    from app.main import app as _fastapi_app
    app = _fastapi_app
except Exception as e:
    # Fallback ASGI app that returns the traceback so Vercel doesn't hide it
    from fastapi import FastAPI, Response
    tb = "".join(traceback.format_exception(e))
    print("=== VERCEL IMPORT FAILURE ===", file=sys.stderr, flush=True)
    print(tb, file=sys.stderr, flush=True)

    app = FastAPI()

    @app.get("/__import_error")
    def import_error():
        return Response(
            content=("Startup import failed in api/index.py\n\n=== Exception ===\n" + tb),
            media_type="text/plain",
            status_code=500,
        )

    @app.get("/{path:path}")
    def catchall(path: str):
        return Response(
            content=(
                "Serverless import failed. Visit /__import_error to see traceback.\n\n"
                "Fix app.main (or its imports) and redeploy."
            ),
            media_type="text/plain",
            status_code=500,
        )

# 3) Make sure app is a package for the import to work
create file app/__init__.py with:
# intentionally empty

# 4) requirements.txt — minimal runtime deps Vercel will install
create file requirements.txt with:
fastapi
pydantic
jinja2
httpx
python-multipart
sse-starlette

# 5) app/config.py — write to /tmp on Vercel; never crash on read/write
# (Only do this replacement if the file exists)
open app/config.py and replace the CONFIG_PATH assignment with:
CONFIG_PATH = os.getenv(
    "APP_CONFIG_PATH",
    "/tmp/config.runtime.json" if os.getenv("APP_ENV") == "vercel" else "app/config.runtime.json"
)

# Also wrap load/save in try/except so import never crashes if file missing:
# (If you don't have these functions, skip)
# def load_config(): try open CONFIG_PATH else return defaults; on failure print warn and return defaults
# def save_config(): wrap open/write in try/except and print warn on failure

# 6) app/main.py — guard import-time work (static/templates) and add /healthz
# (If your file already mounts static/templates, wrap in try/exists checks as below)
open app/main.py and ensure it contains the following patterns (edit, don't duplicate):
# ---
# from fastapi import FastAPI
# from pathlib import Path
# app = FastAPI()
# templates = None
# try:
#     from fastapi.templating import Jinja2Templates
#     from fastapi.staticfiles import StaticFiles
#     base = Path(__file__).resolve().parent
#     static_dir = base / "web" / "static"
#     templates_dir = base / "web" / "templates"
#     if static_dir.exists():
#         app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")
#     else:
#         print(f"[WARN] no static dir: {static_dir}")
#     if templates_dir.exists():
#         templates = Jinja2Templates(directory=str(templates_dir))
#     else:
#         print(f"[WARN] no templates dir: {templates_dir}")
# except Exception as e:
#     print(f"[WARN] static/templates setup skipped: {e}")
#
# @app.get("/healthz")
# def healthz():
#     return {"ok": True}
#
# if __name__ == "__main__":
#     import uvicorn, os
#     uvicorn.run("app.main:app", host="0.0.0.0", port=int(os.getenv("PORT", "8000")), reload=True)
# ---

# 7) Guard any Anthropic/LLM imports so missing API keys don't crash import
# In app/llm/anthropic.py (if exists), ensure no API calls happen at import time.
# Only read ANTHROPIC_API_KEY inside the function that makes the request.

# === End patch ===
